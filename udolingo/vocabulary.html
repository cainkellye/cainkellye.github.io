<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary - Udolingo</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" href="udolingo-icon.png">
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div id="sidebar" class="sidebar">
            <div id="sidebar-header" class="sidebar-header">
                <img alt="mascot" src="udolingo-icon.png" width="30" height="30" />
                <h3>Vocabulary Controls</h3>
                <span class="sidebar-toggle" id="sidebar-toggle">▼</span>
            </div>
            
            <div class="sidebar-content" id="sidebar-content">
                <div class="sidebar-section">
                    <button onclick="window.close()">Close Vocabulary</button>
                </div>
                
                <div class="sidebar-section">
                    <select id="language-pair-select" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 5px; background: white; color: #333; margin-bottom: 0.5rem;">
                        <option value="" title="Use the vocabulary under an exercise to create, or import from file">No vocabulary pairs</option>
                    </select>
                </div>

                <div class="sidebar-section">
                    <button id="switch-direction-btn" disabled>Switch Direction</button>
                    <button id="add-entry-btn" disabled>Add New Entry</button>
                    <button id="save-changes-btn" disabled>Save Changes</button>
                </div>

                <div class="sidebar-section">
                    <button id="export-vocab-btn" disabled>Export Vocabulary</button>
                    <input type="file" id="import-file-input" accept=".txt,.csv" style="display: none;">
                    <button id="import-vocab-btn">Import from File</button>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="container" style="max-width: 60rem;">
                <div id="lesson-header">
                    <img alt="mascot" src="images/udo-normal.png" width="80" height="80" />
                    <h2 id="vocabulary-title" class="main-title">Vocabulary Manager</h2>
                </div>
                
                <div id="vocabulary-info">
                    <p id="vocabulary-description">
                        Select a language pair from the control panel to view and edit your vocabulary.
                        <br/>
                        If there are none yet, use the vocabulary box under an exercise to create one with those words.
                    </p>
                </div>
                
                <div id="vocabulary-container" style="display: none;">
                    <div id="vocabulary-grid" class="vocab-grid" style="max-height: 62vh;">
                        <!-- Vocabulary entries will be inserted here -->
                    </div>
                </div>
                
                <div id="no-vocabulary-message" style="display: none; text-align: center; padding: 2rem; color: #666; font-style: italic;">
                    <p>No vocabulary entries found for this language pair.</p>
                    <p>Add vocabulary entries from the main app exercises to see them here.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="import-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3>Import Vocabulary</h3>
            <p>File format should start with a header line: <code>Vocabulary: sourceLang → targetLang</code></p>
            <p>Followed by vocabulary entries: <code>expression → translation1, translation2, ...</code></p>
            <p>Each entry on a separate line. Supported separators: →, ->, |, tab, :, =</p>
            
            <textarea id="import-preview" rows="10" style="width: 100%; margin: 1rem 0; font-family: monospace; font-size: 0.9rem;"></textarea>
            
            <div class="modal-buttons">
                <button id="confirm-import-btn">Import</button>
                <button id="cancel-import-btn">Cancel</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { StorageManager } from './js/utils/storage-manager.js';
        import { VocabularyRenderer } from './js/utils/vocabulary-renderer.js';

        class VocabularyPage {
            constructor() {
                this.currentLanguagePair = null;
                this.currentDirection = 'normal'; // 'normal' or 'reverse'
                this.vocabularyData = {};
                this.init();
            }

            init() {
                this.loadVocabularyData();
                this.populateLanguagePairs();
                this.setupEventListeners();
                this.setupMobileResponsive();
            }

            setupMobileResponsive() {
                // Handle sidebar toggle for mobile
                document.getElementById('sidebar-header').addEventListener('click', () => {
                    const sidebar = document.getElementById('sidebar');
                    const toggle = document.getElementById('sidebar-toggle');
                    const content = document.getElementById('sidebar-content');
                    
                    if (window.innerWidth <= 768) {
                        sidebar.classList.toggle('collapsed');
                        
                        if (sidebar.classList.contains('collapsed')) {
                            content.style.display = 'none';
                            toggle.style.transform = 'rotate(-90deg)';
                        } else {
                            content.style.display = 'block';
                            toggle.style.transform = 'rotate(0deg)';
                        }
                    }
                });
            }

            loadVocabularyData() {
                this.vocabularyData = StorageManager.getCentralVocabulary() || {};
                console.log('Loaded vocabulary data:', this.vocabularyData);
            }

            populateLanguagePairs() {
                const select = document.getElementById('language-pair-select');
                const pairs = Object.keys(this.vocabularyData);
                
                // Clear existing options
                select.innerHTML = '';
                
                if (pairs.length === 0) {
                    select.innerHTML = '<option value="">No vocabulary pairs available</option>';
                    return;
                }
                
                // Add default option
                select.innerHTML = '<option value="">Select a language pair...</option>';
                
                // Add language pairs
                pairs.forEach(pairKey => {
                    const [lang1, lang2] = pairKey.split(':');
                    const displayName = `${lang1.charAt(0).toUpperCase() + lang1.slice(1)} ↔ ${lang2.charAt(0).toUpperCase() + lang2.slice(1)}`;
                    const option = document.createElement('option');
                    option.value = pairKey;
                    option.textContent = displayName;
                    select.appendChild(option);
                });
            }

            setupEventListeners() {
                // Language pair selection
                document.getElementById('language-pair-select').addEventListener('change', (e) => {
                    this.selectLanguagePair(e.target.value);
                    this.closeSidebarOnMobile();
                });

                // Switch direction button
                document.getElementById('switch-direction-btn').addEventListener('click', () => {
                    this.switchDirection();
                    this.closeSidebarOnMobile();
                });

                // Add new entry button
                document.getElementById('add-entry-btn').addEventListener('click', () => {
                    this.addNewEntry();
                });

                // Save changes button
                document.getElementById('save-changes-btn').addEventListener('click', () => {
                    this.saveVocabularyChanges();
                    this.closeSidebarOnMobile();
                });

                // Export button
                document.getElementById('export-vocab-btn').addEventListener('click', () => {
                    this.exportVocabulary();
                    this.closeSidebarOnMobile();
                });

                // Import button
                document.getElementById('import-vocab-btn').addEventListener('click', () => {
                    document.getElementById('import-file-input').click();
                });

                // File input
                document.getElementById('import-file-input').addEventListener('change', (e) => {
                    this.handleFileImport(e);
                });

                // Import modal buttons
                document.getElementById('confirm-import-btn').addEventListener('click', () => {
                    this.confirmImport();
                });

                document.getElementById('cancel-import-btn').addEventListener('click', () => {
                    this.hideImportModal();
                });
            }

            selectLanguagePair(pairKey) {
                if (!pairKey) {
                    this.currentLanguagePair = null;
                    this.hideVocabulary();
                    return;
                }

                this.currentLanguagePair = pairKey;
                this.currentDirection = 'normal';
                this.loadLanguagePairVocabulary();
                this.updateUI();
            }

            loadLanguagePairVocabulary() {
                if (!this.currentLanguagePair) return;

                const compressedData = this.vocabularyData[this.currentLanguagePair];
                if (!compressedData) {
                    this.showNoVocabulary();
                    return;
                }

                const vocabularyEntries = StorageManager.decompressData(compressedData) || [];
                this.displayVocabulary(vocabularyEntries);
            }

            displayVocabulary(entries) {
                const container = document.getElementById('vocabulary-container');
                const grid = document.getElementById('vocabulary-grid');
                const noVocabMsg = document.getElementById('no-vocabulary-message');
                const description = document.getElementById('vocabulary-description');

                if (!entries || entries.length === 0) {
                    this.showNoVocabulary();
                    return;
                }

                // Hide other elements and show vocabulary
                description.style.display = 'none';
                noVocabMsg.style.display = 'none';
                container.style.display = 'block';

                // Clear existing content
                VocabularyRenderer.clearGrid(grid);

                // Group entries by source word and combine translations
                const groupedEntries = this.groupEntriesBySourceWord(entries);

                // Sort entries alphabetically by the source language
                const sortedEntries = Object.keys(groupedEntries).sort((a, b) => 
                    a.toLowerCase().localeCompare(b.toLowerCase())
                );

                // Create vocabulary rows
                sortedEntries.forEach(sourceWord => {
                    const translations = groupedEntries[sourceWord];
                    VocabularyRenderer.createVocabularyRow(sourceWord, translations.join(', '), grid);
                });

                // Add button at the end of the grid to add new entries
                VocabularyRenderer.addGridAddButton(grid, () => {
                    this.addNewEntry();
                });

                // Update vocabulary info
                this.updateVocabularyInfo(sortedEntries.length);
            }

            groupEntriesBySourceWord(entries) {
                const grouped = {};
                
                entries.forEach(entry => {
                    if (Array.isArray(entry) && entry.length === 2) {
                        const [primary, secondary] = entry;
                        
                        // Here we show striked out entries too, so the user can edit them
                        
                        const sourceWord = this.currentDirection === 'normal' ? primary : secondary;
                        const targetWord = this.currentDirection === 'normal' ? secondary : primary;
                        
                        if (!grouped[sourceWord]) {
                            grouped[sourceWord] = [];
                        }
                        
                        // Add translation if not already present
                        if (!grouped[sourceWord].includes(targetWord)) {
                            grouped[sourceWord].push(targetWord);
                        }
                    }
                });

                return grouped;
            }

            showNoVocabulary() {
                const container = document.getElementById('vocabulary-container');
                const noVocabMsg = document.getElementById('no-vocabulary-message');
                const description = document.getElementById('vocabulary-description');

                description.style.display = 'none';
                container.style.display = 'none';
                noVocabMsg.style.display = 'block';
            }

            showEmptyVocabularyGrid() {
                const container = document.getElementById('vocabulary-container');
                const grid = document.getElementById('vocabulary-grid');
                const noVocabMsg = document.getElementById('no-vocabulary-message');
                const description = document.getElementById('vocabulary-description');

                // Hide other elements and show vocabulary container
                description.style.display = 'none';
                noVocabMsg.style.display = 'none';
                container.style.display = 'block';

                // Clear existing content and add the add button
                VocabularyRenderer.clearGrid(grid, () => {
                    this.addNewEntry();
                });
                
                // Update vocabulary info
                this.updateVocabularyInfo(0);
            }

            hideVocabulary() {
                const container = document.getElementById('vocabulary-container');
                const noVocabMsg = document.getElementById('no-vocabulary-message');
                const description = document.getElementById('vocabulary-description');
                const title = document.getElementById('vocabulary-title');

                container.style.display = 'none';
                noVocabMsg.style.display = 'none';
                description.style.display = 'block';
                description.textContent = 'Select a language pair from the sidebar to view and edit your vocabulary.';
                title.innerHTML = 'Central Vocabulary';
            }

            updateUI() {
                const switchBtn = document.getElementById('switch-direction-btn');
                const exportBtn = document.getElementById('export-vocab-btn');
                const addEntryBtn = document.getElementById('add-entry-btn');
                const saveChangesBtn = document.getElementById('save-changes-btn');
                
                const hasSelection = !!this.currentLanguagePair;
                switchBtn.disabled = !hasSelection;
                exportBtn.disabled = !hasSelection;
                addEntryBtn.disabled = !hasSelection;
                saveChangesBtn.disabled = !hasSelection;

                if (hasSelection) {
                    const [lang1, lang2] = this.currentLanguagePair.split(':');
                    const sourceLang = this.currentDirection === 'normal' ? lang1 : lang2;
                    const targetLang = this.currentDirection === 'normal' ? lang2 : lang1;
                    
                    switchBtn.textContent = `Switch to ${targetLang.charAt(0).toUpperCase() + targetLang.slice(1)} → ${sourceLang.charAt(0).toUpperCase() + sourceLang.slice(1)}`;
                } else {
                    switchBtn.textContent = 'Switch Direction';
                }
            }

            updateVocabularyInfo(count) {
                if (!this.currentLanguagePair) return;

                const [lang1, lang2] = this.currentLanguagePair.split(':');
                const sourceLang = this.currentDirection === 'normal' ? lang1 : lang2;
                const targetLang = this.currentDirection === 'normal' ? lang2 : lang1;
                
                const description = document.getElementById('vocabulary-description');
                description.style.display = 'block';
                description.innerHTML = `<strong>${count} entries</strong>`;
                
                const title = document.getElementById('vocabulary-title');
                title.innerHTML = `${sourceLang.charAt(0).toUpperCase() + sourceLang.slice(1)} → ${targetLang.charAt(0).toUpperCase() + targetLang.slice(1)} Vocabulary`
            }

            switchDirection() {
                if (!this.currentLanguagePair) return;
                
                this.currentDirection = this.currentDirection === 'normal' ? 'reverse' : 'normal';
                this.loadLanguagePairVocabulary();
                this.updateUI();
            }

            exportVocabulary() {
                if (!this.currentLanguagePair) return;

                const compressedData = this.vocabularyData[this.currentLanguagePair];
                if (!compressedData) {
                    alert('No vocabulary data to export.');
                    return;
                }

                const vocabularyEntries = StorageManager.decompressData(compressedData) || [];
                if (vocabularyEntries.length === 0) {
                    alert('No vocabulary entries to export.');
                    return;
                }

                // Group entries by source word and combine translations
                const groupedEntries = this.groupEntriesBySourceWord(vocabularyEntries);
                
                if (Object.keys(groupedEntries).length === 0) {
                    alert('No valid vocabulary entries to export.');
                    return;
                }

                const [lang1, lang2] = this.currentLanguagePair.split(':');
                const sourceLang = this.currentDirection === 'normal' ? lang1 : lang2;
                const targetLang = this.currentDirection === 'normal' ? lang2 : lang1;
                
                // Create header line with language pair and direction
                const headerLine = `Vocabulary: ${sourceLang} → ${targetLang}`;
                
                // Format entries for export
                const exportLines = [];
                Object.keys(groupedEntries).forEach(sourceWord => {
                    const translations = groupedEntries[sourceWord];
                    exportLines.push(`${sourceWord} → ${translations.join(', ')}`);
                });

                // Sort alphabetically
                exportLines.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

                // Combine header and entries
                const content = [headerLine, ...exportLines].join('\n');
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                
                const filename = `vocabulary_${sourceLang}_to_${targetLang}.txt`;
                
                // Create download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log(`Exported ${exportLines.length} vocabulary entries to ${filename}`);
            }

            handleFileImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    this.showImportModal(content);
                };
                reader.readAsText(file);
            }

            showImportModal(content) {
                const modal = document.getElementById('import-modal');
                const preview = document.getElementById('import-preview');
                
                preview.value = content;
                modal.style.display = 'flex';
            }

            hideImportModal() {
                document.getElementById('import-modal').style.display = 'none';
                document.getElementById('import-file-input').value = '';
            }

            confirmImport() {
                const content = document.getElementById('import-preview').value;
                const lines = content.split('\n').filter(line => line.trim());
                
                if (lines.length === 0) {
                    alert('No valid entries found in the file.');
                    return;
                }

                // Check for vocabulary header line
                const firstLine = lines[0].trim();
                let importPairKey = null;
                let importDirection = 'normal';
                let vocabularyLines = lines;

                // Parse header if it exists
                if (firstLine.startsWith('Vocabulary:')) {
                    const headerMatch = firstLine.match(/Vocabulary:\s*(\w+)\s*→\s*(\w+)/);
                    if (!headerMatch) {
                        alert('Invalid header format. Expected format: "Vocabulary: sourceLang → targetLang"\n\nPlease add this header as the first line of your file.');
                        return;
                    }

                    const [, sourceLang, targetLang] = headerMatch;
                    
                    // Find the matching language pair key
                    const availablePairs = Object.keys(this.vocabularyData);
                    importPairKey = availablePairs.find(pairKey => {
                        const [lang1, lang2] = pairKey.split(':');
                        return (lang1 === sourceLang.toLowerCase() && lang2 === targetLang.toLowerCase()) ||
                               (lang1 === targetLang.toLowerCase() && lang2 === sourceLang.toLowerCase());
                    });

                    if (!importPairKey) {
                        // Create new language pair key if it doesn't exist
                        const sortedLangs = [sourceLang.toLowerCase(), targetLang.toLowerCase()].sort();
                        importPairKey = sortedLangs.join(':');
                    }

                    // Determine import direction
                    const [lang1, lang2] = importPairKey.split(':');
                    importDirection = (lang1 === sourceLang.toLowerCase()) ? 'normal' : 'reverse';
                    
                    // Remove header line from vocabulary lines
                    vocabularyLines = lines.slice(1);
                    
                    console.log(`Importing for pair: ${importPairKey}, direction: ${importDirection}`);
                } else {
                    // No header found - show error
                    alert('Missing vocabulary header!\n\nPlease add a header line as the first line of your file in this format:\nVocabulary: sourceLang → targetLang\n\nExample: Vocabulary: en → hu');
                    return;
                }

                if (vocabularyLines.length === 0) {
                    alert('No vocabulary entries found after the header line.');
                    return;
                }

                let importedCount = 0;
                const compressedData = this.vocabularyData[importPairKey];
                const existingEntries = compressedData ? StorageManager.decompressData(compressedData) || [] : [];

                vocabularyLines.forEach(line => {
                    // Try to split with common separators
                    const separators = ['→', '->', '|', '\t', ':', '='];
                    let source = '';
                    let translationsText = '';

                    for (const sep of separators) {
                        if (line.includes(sep)) {
                            const parts = line.split(sep, 2);
                            source = parts[0].trim();
                            translationsText = parts[1] ? parts[1].trim() : '';
                            break;
                        }
                    }

                    if (source && translationsText) {
                        // Split multiple translations by comma
                        const translations = translationsText
                            .split(',')
                            .map(t => t.trim())
                            .filter(t => t.length > 0);

                        translations.forEach(translation => {
                            // Determine correct order based on import direction and language pair
                            const [lang1, lang2] = importPairKey.split(':');
                            let primaryWord, secondaryWord;
                        
                            if (importDirection === 'normal') {
                                primaryWord = source;
                                secondaryWord = translation;
                            } else {
                                primaryWord = translation;
                                secondaryWord = source;
                            }

                            // Check if entry already exists
                            const existsAlready = existingEntries.some(entry => 
                                Array.isArray(entry) && entry.length === 2 && 
                                entry[0].toLowerCase() === primaryWord.toLowerCase() && 
                                entry[1].toLowerCase() === secondaryWord.toLowerCase()
                            );

                            if (!existsAlready) {
                                existingEntries.push([primaryWord, secondaryWord]);
                                importedCount++;
                            }
                        });
                    }
                });

                if (importedCount > 0) {
                    // Save updated vocabulary to local data
                    this.vocabularyData[importPairKey] = StorageManager.compressData(existingEntries);
                    
                    // Save to localStorage
                    StorageManager.setCentralVocabulary(this.vocabularyData);
                    
                    // Refresh language pair dropdown
                    this.populateLanguagePairs();
                    
                    // Set the dropdown value and update the internal state properly
                    document.getElementById('language-pair-select').value = importPairKey;
                    this.currentLanguagePair = importPairKey;
                    this.currentDirection = importDirection;
                    this.loadLanguagePairVocabulary();
                    this.updateUI();
                    
                    const [lang1, lang2] = importPairKey.split(':');
                    const sourceLang = importDirection === 'normal' ? lang1 : lang2;
                    const targetLang = importDirection === 'normal' ? lang2 : lang1;
                    
                    alert(`Successfully imported ${importedCount} new vocabulary entries for ${sourceLang} → ${targetLang}.`);
                    
                    // Close sidebar on mobile after successful import
                    this.closeSidebarOnMobile();
                } else {
                    alert('No new entries were imported. All entries may already exist.');
                }

                this.hideImportModal();
            }

            saveVocabularyChanges() {
                if (!this.currentLanguagePair) {
                    alert('No language pair selected.');
                    return;
                }

                const entries = VocabularyRenderer.getVocabularyInputs();
                
                if (entries.length === 0) {
                    alert('No vocabulary entries to save.');
                    return;
                }

                const [lang1, lang2] = this.currentLanguagePair.split(':');
                const sourceLang = this.currentDirection === 'normal' ? lang1 : lang2;
                const targetLang = this.currentDirection === 'normal' ? lang2 : lang1;
                
                // Get existing entries
                let compressedData = this.vocabularyData[this.currentLanguagePair];
                let existingEntries = compressedData ? StorageManager.decompressData(compressedData) || [] : [];
                
                // Clear all existing entries for this language pair (we'll rebuild from the UI)
                existingEntries = [];
                
                let savedCount = 0;

                entries.forEach(entry => {
                    const { source, translation } = entry;
                    
                    if (source) {
                        if (translation) {
                            // Split multiple translations by comma
                            const translations = translation
                                .split(',')
                                .map(t => t.trim())
                                .filter(t => t.length > 0);
                            
                            translations.forEach(trans => {
                                // Determine correct order based on current direction and language pair
                                let primaryWord, secondaryWord;
                                
                                if (this.currentDirection === 'normal') {
                                    primaryWord = source;
                                    secondaryWord = trans;
                                } else {
                                    primaryWord = trans;
                                    secondaryWord = source;
                                }
                                
                                existingEntries.push([primaryWord, secondaryWord]);
                                savedCount++;
                            });
                        }
                        // If source exists but no translation, we simply don't add it (deletion by empty translation)
                    }
                });

                // Save updated vocabulary
                this.vocabularyData[this.currentLanguagePair] = StorageManager.compressData(existingEntries);
                StorageManager.setCentralVocabulary(this.vocabularyData);
                
                // Refresh display
                this.loadLanguagePairVocabulary();
                
                if (savedCount > 0) {
                    alert(`Saved ${savedCount} vocabulary entries for ${sourceLang} → ${targetLang}.`);
                } else {
                    alert('All entries have been removed (empty translations delete entries).');
                }
            }

            addNewEntry() {
                if (!this.currentLanguagePair) return;

                const grid = document.getElementById('vocabulary-grid');
                if (!grid) return;

                const container = document.getElementById('vocabulary-container');
                
                // If container is hidden, show empty grid first
                if (container.style.display === 'none') {
                    this.showEmptyVocabularyGrid();
                    return;
                }

                // Create a new empty vocabulary row
                VocabularyRenderer.createVocabularyRow('', '', grid);
                
                // Re-add the grid add button
                VocabularyRenderer.addGridAddButton(grid, () => {
                    this.addNewEntry();
                });
                
                // Focus on the new input
                VocabularyRenderer.focusLastSourceInput(grid);

                // Close sidebar on mobile
                this.closeSidebarOnMobile();
            }

            closeSidebarOnMobile() {
                if (window.innerWidth <= 768) {
                    const sidebar = document.getElementById('sidebar');
                    const toggle = document.getElementById('sidebar-toggle');
                    const content = document.getElementById('sidebar-content');
                    
                    if (sidebar && !sidebar.classList.contains('collapsed')) {
                        sidebar.classList.add('collapsed');
                        if (content) content.style.display = 'none';
                        if (toggle) toggle.style.transform = 'rotate(-90deg)';
                    }
                }
            }
        }

        // Initialize the vocabulary page
        document.addEventListener('DOMContentLoaded', () => {
            new VocabularyPage();
        });
    </script>
</body>
</html>